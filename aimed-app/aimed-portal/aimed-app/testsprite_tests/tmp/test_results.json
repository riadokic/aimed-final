[
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "64017a82-bb71-4f41-a78f-c3525ecb3b09",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC008-Successful email/password login redirects to dashboard",
    "description": "Verifies that a returning user can log in with valid credentials and is redirected to the dashboard.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' link/button to navigate to the login page (/login).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' link/button (interactive element index 106) to navigate to the login page (/login) and then verify the URL contains '/login'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with the exact credentials and submit the form to attempt login (inputs: example@gmail.com / password123).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # -> Assert we are on the login page\n        frame = context.pages[-1]\n        await frame.wait_for_url(\"**/login**\", timeout=10000)\n        assert \"/login\" in frame.url, f\"Expected '/login' in URL but got: {frame.url}\"\n        \n        # -> After submitting the form, wait for redirect to the dashboard and assert\n        frame = context.pages[-1]\n        await frame.wait_for_url(\"**/dashboard**\", timeout=15000)\n        assert \"/dashboard\" in frame.url, f\"Expected '/dashboard' in URL but got: {frame.url}\"\n        \n        # -> Verify the 'Dashboard' text is visible on the page\n        dashboard_loc = frame.locator(\"text=Dashboard\")\n        await dashboard_loc.wait_for(state=\"visible\", timeout=5000)\n        assert await dashboard_loc.is_visible(), \"Expected 'Dashboard' text to be visible on the dashboard page\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/177125871982439//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.159Z",
    "modified": "2026-02-16T16:18:39.939Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "43cc5e13-8927-459e-b278-6e3be504c1d7",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC014-Pressing Enter in password field submits login and redirects on success",
    "description": "Verifies that pressing Enter from the password field submits the form and logs in successfully with valid credentials.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (login) link to open the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' link (index 101) to open the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email field with example@gmail.com (input index 1030) as the immediate action.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # Press Enter in the password field to submit the form\n        await page.wait_for_timeout(500)\n        await elem.press('Enter')\n        \n        # Wait for redirect to the dashboard\n        await page.wait_for_url('**/dashboard**', timeout=10000)\n        \n        # Assert the URL contains /dashboard\n        assert '/dashboard' in page.url, f\"Expected '/dashboard' in URL, got: {page.url}\"\n        \n        # Assert the Dashboard text is visible on the page\n        dashboard_locator = page.locator(\"text=Dashboard\")\n        await dashboard_locator.wait_for(state='visible', timeout=5000)\n        assert await dashboard_locator.is_visible(), \"Expected 'Dashboard' text to be visible after login\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258709420741//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.166Z",
    "modified": "2026-02-16T16:18:29.543Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "1926c484-2772-44e9-9d4e-5343e1838d3b",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC018-Step 1 validation: specialization required prevents advancing",
    "description": "Verifies validation blocks moving past Step 1 when the mandatory specialization is empty.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' link/button to open the login page (/login).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' header link (index 102) to open the login page (/login).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email field with example@gmail.com, fill the password with password123, then click the 'Prijavite se' submit button to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the new report flow by clicking 'Novi nalaz' in the sidebar to reach Step 1 where 'Korak 1' should appear.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Započni diktiranje' (Start dictation) button to open the new report flow / Step 1 and reveal 'Korak 1'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div[1]/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Try to recover the new-report (Step 1) view: wait briefly, reload /novi-nalaz to force the SPA to load, then search the page for the text 'Korak 1' to confirm Step 1 presence.\n        await page.goto(\"http://localhost:3000/novi-nalaz\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Nastavi' button to proceed from patient data to Step 1 so 'Korak 1' appears and validation can be tested.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the required patient name fields (Ime, Prezime) and click 'Nastavi' to advance to Step 1 so 'Korak 1' can be validated.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marković')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Step 1 view by trying an alternative navigation: click the 'Kreiraj nalaz' button to ensure the create-flow/step view is active, then locate 'Korak 1'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Kreiraj nalaz' to open the Step 1 view and then check the page for the text 'Korak 1' (confirm Step 1 is visible). If visible, proceed to fill doctor name in the next actions.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Try a different interaction path to reveal Step 1: re-select 'Kreiraj nalaz' to ensure create-flow is active, then search the page for the text 'Korak 1' to detect Step 1. If 'Korak 1' appears, proceed to fill doctor name and check validation next.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Try an alternative navigation to activate the create-flow Step 1: click the sidebar 'Novi nalaz' link (index 2188) to reload/reset the flow and then check for 'Korak 1'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Obavezno').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected to see the 'Obavezno' validation message preventing progression past Step 1 when the doctor's mandatory specialization is left empty, but the required-field error did not appear\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test could not be completed: Step 1 ('Korak 1') was not reachable so the mandatory-specialization validation could not be verified.\n\nWhat was attempted:\n- Logged in with provided credentials (example@gmail.com / password123) and reached /dashboard.\n- Opened 'Novi nalaz' and attempted to start the create-flow (Kreiraj nalaz / Započni diktiranje).\n- Filled patient name fields (Ime='Marko', Prezime='Marković').\n- Clicked 'Nastavi' twice; first click produced validation 'Ime i prezime su obavezni.' then names were filled and second click did not reveal 'Korak 1'.\n- Re-tried 'Kreiraj nalaz' / navigation several times; 'Korak 1' text not found in the DOM.\n\nCurrent page state (evidence):\n- URL: http://localhost:3000/novi-nalaz\n- Visible: patient form with inputs (Ime index 2344, Prezime index 2346, JMBG index 2350, Datum index 2371, Telefon 2375, Email 2379, Adresa 2383) and 'Nastavi' button (index 2384).\n- 'Korak 1' search: not found.\n\nReason for stopping:\n- Step 1 cannot be reached after multiple different actions. The same critical navigation actions ('Nastavi', 'Kreiraj nalaz') were already attempted twice and did not expose Step 1. Per test-run constraints, repeating these failing actions further is not appropriate.\n\nSuggested next steps (choose one):\n1) Provide the index of the doctor name / Step 1 input (if it is present but not found by text search), or indicate how to open Step 1 in the UI.\n2) Allow direct navigation to Step 1 URL (if available) so the specialization validation can be tested.\n3) Provide any missing required patient fields that must be filled before Step 1 appears (if different fields are required).\n\nIf new instructions are given, the test can continue. Current test status: NOT COMPLETED. Success=false.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771259065651932//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.172Z",
    "modified": "2026-02-16T16:24:25.776Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "46d69149-1de9-49bd-9daf-0b3ee5ace430",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC019-Step 2 optional clinic info: fill fields and proceed with Next",
    "description": "Verifies clinic info can be entered on Step 2 and the wizard proceeds to Step 3.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' link to open the login page (navigate to /login).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the login page by clicking the 'Prijava' link (use interactive element index 103).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with the provided credentials and click the 'Prijavite se' button to submit the login form (use inputs 1010, 1014 and button 1015).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open Settings (Postavke) to find the onboarding wizard or clinic settings so the onboarding/step 2 can be reached.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Postavke' (Settings) link in the sidebar to open the settings page and locate the onboarding wizard (to reach Korak 2).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the clinic fields on the Settings page with the provided test values, then search the page for 'Korak 3' to see if wizard progressed (if wizard not present, verification of progression will fail).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/div[2]/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Poliklinika Test')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test ulica 1')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('+38761111222')\n        \n        # -> Fill the clinic website field with 'https://example-clinic.test' (input index 1480), then search the page for the text 'Korak 3' to verify wizard progression.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div[2]/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('https://example-clinic.test')\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Korak 3').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: expected the onboarding wizard to advance to 'Korak 3' after entering clinic name, address, phone and website on Step 2, but 'Korak 3' was not visible — the wizard did not proceed as expected\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of results and final status:\n- What was attempted: Verified that clinic information could be entered on Step 2 and attempted to progress the onboarding wizard to Step 3.\n- What was actually done: Logged in with the provided test account, opened Settings (/postavke), and entered/confirmed the following clinic fields:\n  - Naziv klinike / ordinacije: Poliklinika Test\n  - Adresa: Test ulica 1\n  - Telefon: +38761111222\n  - Web stranica: https://example-clinic.test\n  These values are visible in the Settings page inputs (page URL: /postavke).\n- Verification of wizard progression: Failed. No onboarding wizard steps ('Korak 1', 'Korak 2', or 'Korak 3') were present on the site while on Settings, and a search/scroll for 'Korak 3' returned no results. Clicking Next to advance to Korak 3 was not possible because the wizard UI was not shown.\n- Likely reason: The test account appears to have completed the onboarding previously or the onboarding flow is not triggered from Settings. The clinic data can be entered via Settings, but it does not trigger or advance an onboarding wizard to Korak 3 in the current session/state.\n- Recommendation to complete the original test case successfully:\n  1) Use a fresh test account that has not completed onboarding, or reset the onboarding state for the existing account (if possible).\n  2) Re-run the steps: login → verify 'Korak 1' visible → fill doctor info → Next → verify 'Korak 2' visible → fill clinic info → Next → verify 'Korak 3'.\nFinal status: success=false — clinic fields can be edited in Settings (PASS for editability), but the requirement 'wizard proceeds to Step 3' could not be verified because the onboarding wizard was not present (FAIL for wizard progression).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258890112902//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.178Z",
    "modified": "2026-02-16T16:21:30.232Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "32935ac1-91fc-42de-be13-fcd91928f161",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC020-Step 3 validation: cannot proceed without at least one report category",
    "description": "Verifies Step 3 requires at least one report category before advancing to Step 4.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' button to open the login page (element index 103).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the login page by clicking the 'Prijava' link/button (index 103) so the login form appears.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill login form: enter email example@gmail.com into email input (index 1011), enter password password123 into password input (index 1015), then click the 'Prijavite se' submit button (index 1016).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open Settings (Postavke) to access the multi-step wizard by clicking the 'Postavke' link (index 1226).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Postavke' link (index 1226) to open Settings and access the multi-step wizard (Korak 1-3).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Dashboard' link (index 1215) to load the dashboard and search for the wizard text 'Korak 1'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Novi nalaz' (index 1216) to open the new report wizard (Korak 1) and continue the verification of Step 3 requirements.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the New Report wizard by clicking 'Novi nalaz' so Korak 1 appears and proceed with the multi-step wizard.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Nastavi' button (index 2129) on the Novi nalaz page to advance to the next wizard step (Korak 2).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the patient 'Ime' and 'Prezime' fields then click 'Nastavi' to advance to Korak 2. Specifically: input 'Marko' into index 2089, 'Markovic' into index 2091, then click index 2129.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Markovic')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Kreiraj nalaz' button (index 2086) to ensure the new-report wizard (Korak 1) starts or to surface the wizard navigation (Next/Skip) controls so the test can continue to Korak 2/3 verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the visible 'Nastavi' button on the Novi nalaz patient form (index 2388) to advance to Korak 2 of the wizard and reveal doctor fields.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt to advance to Korak 2 by clicking the 'Nastavi' button again to reveal doctor fields and continue the wizard (click index 2388). If the page still does not advance after this second click, stop and report inability to proceed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter patient Ime into input index 2348 and Prezime into index 2350, then click 'Nastavi' (index 2388) to advance to Korak 2.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Markovic')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Započni diktiranje' (index 2492) to open the report editor/wizard and proceed to Korak 2/3 to verify the category validation.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Pause the recording (click 'Pauza') to reveal finish/submit controls so the report editor/wizard can be accessed and proceed to Korak 2/3 to verify category validation.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div/div[3]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the microphone error dialog by clicking 'Nazad' so the patient form/editor is visible, then continue to advance the wizard toward Korak 2/3 to verify the 'Dodajte barem jednu kategoriju' validation.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div/div/div[3]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the visible 'Nastavi' button on the patient form to attempt advancing to Korak 2 so doctor fields become available (click index 2647).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill patient Ime into input index 2607 and Prezime into input index 2609, then click 'Nastavi' (index 2647) to attempt advancing to Korak 2.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Markovic')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Kreiraj nalaz' button (index 2604) to reinitialize the new-report flow and attempt to reveal wizard navigation controls so the wizard can be advanced to Korak 2/3.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Ažuriraj postojeći' (index 2605) to select an existing patient and continue the wizard without triggering the patient-save error, then proceed to Korak 2/3 to verify 'Dodajte barem jednu kategoriju'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter an existing patient into the search field (index 2759) to select the patient and then proceed toward Korak 2/3 so the Step 3 validation can be tested.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko Markovic')\n        \n        # -> Try the existing-patient search again with a shorter query ('Marko') and press Enter so a patient can be selected; after selection, reveal wizard navigation to advance to Korak 2/3 and continue to the Step 3 validation.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko')\n        \n        # -> Reset the flow by navigating back to Dashboard and re-opening Novi nalaz to try selecting/creating a patient again (click Dashboard then Novi nalaz). If patient selection still fails, report inability to reach Korak 3 and stop.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Try alternate approach to start the new-report flow: open the 'Kreiraj nalaz' patient creation mode again to attempt to create/select a patient (click index 2604). If save error persists, next attempt will be to navigate to Pacijenti to create a patient there.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the visible 'Nastavi' button (index 2912) to attempt advancing to Korak 2 so doctor fields become available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the patient Ime and Prezime using the shadow inputs (indices 2872 and 2874) then click 'Nastavi' (index 2912) to attempt advancing to Korak 2 so the doctor fields and subsequent Korak 3 can be accessed.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Markovic')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Pacijenti page to create/select a patient there so the new-report wizard can be started and advanced to Korak 2/3 (immediate action: click 'Pacijenti').\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # Assertions for Step 3 validation: ensure we are on Korak 3 and that the category-required message is shown\n        frame = context.pages[-1]\n        # Wait for Step 3 header to appear\n        await frame.wait_for_selector(\"text=Korak 3\", timeout=5000)\n        assert await frame.locator(\"text=Korak 3\").is_visible(), \"Expected 'Korak 3' to be visible\"\n        # The wizard should not advance to Korak 4 when no categories are selected\n        # If Korak 4 appears, the flow advanced incorrectly\n        if await frame.locator(\"text=Korak 4\").count() > 0:\n            assert not await frame.locator(\"text=Korak 4\").is_visible(), \"Unexpectedly advanced to 'Korak 4' without categories\"\n        # Verify the validation message prompting to add at least one category is visible\n        await frame.wait_for_selector(\"text=Dodajte barem jednu kategoriju\", timeout=5000)\n        assert await frame.locator(\"text=Dodajte barem jednu kategoriju\").is_visible(), \"Expected validation message 'Dodajte barem jednu kategoriju' to be visible when no category is selected\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771259425247888//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.185Z",
    "modified": "2026-02-16T16:30:25.398Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "38c9ea54-8aa8-48f7-b986-beee08a8a15f",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC022-Skip Step 2 does not block completion and Step 4 can be finished without uploads",
    "description": "Verifies optional steps (clinic and branding) can be skipped/left empty and onboarding still completes.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' button to open the login page (use element index 102).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the login page by clicking the 'Prijava' button on the homepage (element index 102).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email field (index 980) with example@gmail.com, fill the password field (index 984) with password123, then click the 'Prijavite se' submit button (index 985).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open Settings (Postavke) to look for onboarding controls or an option to rerun onboarding so the optional steps (clinic and branding) can be tested/skipped.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open Settings by clicking the 'Postavke' link (element index 1195) to find the option to rerun onboarding so optional steps can be tested/skipped.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate directly to the onboarding page (/onboarding) to start the onboarding flow so optional steps (clinic and branding) can be tested/skipped.\n        await page.goto(\"http://localhost:3000/onboarding\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open Settings (Postavke) from the sidebar to look for onboarding controls or a rerun/reset option since /onboarding returned 404.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Dashboard').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test was verifying that skipping optional clinic and branding steps still completes onboarding and redirects to the dashboard. Expected to find 'Dashboard' on the page after finishing onboarding, but it was not visible.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Unable to complete the requested verification: optional onboarding steps (clinic and branding) could not be tested because the onboarding flow cannot be started. Summary of findings:\n\n- Login: test account login succeeded using the provided credentials (example@gmail.com / password123) and redirected to /dashboard.\n- Settings: Settings (Postavke) page opened and was inspected. No UI control or text found to rerun or reset onboarding (searched once; 2 search attempts remain).\n- Direct access: Navigated directly to /onboarding; page returned 404 (This page could not be found). Current tab shows the 404 page.\n- Result: Onboarding flow cannot be reached, so it is not possible to verify that optional steps (clinic and branding) can be skipped and still complete onboarding. Onboarding steps completed: 0/18.\n\nRecommended next steps for the team to enable the verification:\n1) Provide a UI action in Settings to rerun/reset onboarding, or\n2) Provide a backend/test endpoint to reset the onboarding-completed flag for the test account, or\n3) Fix /onboarding route so direct navigation works for authenticated users.\n\nIf one of the above is provided, re-run the test: log in (example@gmail.com / password123), start onboarding, skip the clinic and branding steps, and verify completion redirects to /dashboard and that 'Onboarding' is not visible.\n\nCurrent status: verification not completed due to inaccessible onboarding. Success=false.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258856000791//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.192Z",
    "modified": "2026-02-16T16:20:56.193Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "0a1d7c7e-f298-43df-bd0e-afb86e4feaed",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC029-Dashboard loads and shows report statistics for an authenticated user",
    "description": "Verifies that an authenticated user can reach the dashboard and see report statistics widgets/values rendered.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the login page by clicking the 'Prijava' (Login) link on the homepage.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the login page by clicking the 'Prijava' link again (element index 106).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and click the 'Prijavite se' submit button to attempt login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # -> Assertions: verify we are on the dashboard and key dashboard sections are visible\n        assert '/dashboard' in page.url, f\"Expected '/dashboard' to be in URL, got: {page.url}\"\n        # Verify the dashboard statistics/overview heading is visible (page shows localized text)\n        elem = page.locator(\"text=Pregled aktivnosti\")\n        assert await elem.is_visible(), \"Expected 'Pregled aktivnosti' to be visible on the dashboard\"\n        # Verify the reports / latest findings section is visible (localized: 'Zadnji nalazi')\n        elem = page.locator(\"text=Zadnji nalazi\")\n        assert await elem.is_visible(), \"Expected 'Zadnji nalazi' to be visible on the dashboard\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258732258967//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.198Z",
    "modified": "2026-02-16T16:18:52.395Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "2a968679-307d-4891-bd5a-14203f7ffbac",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC030-Open a recent report from Dashboard",
    "description": "Verifies that clicking a recent report item navigates to an in-app report detail/editor view.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link to open the login page (use interactive element index 101).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' link again (index 101) to open the login page and reveal the email/password fields.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type example@gmail.com into the email field (index 970), then fill password and submit the form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Započni diktiranje' (start dictation) to create/open a new report so a Recent report item will be available to click.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div[1]/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the report editor by clicking 'Započni diktiranje' again so a recent report item can be created or an editor/detail view will open (click element index 1281).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div[1]/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Nastavi' button to proceed from the patient form and open/create the report editor/detail view so a Recent report item exists.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill required patient fields (Name and Surname) and click 'Nastavi' to create/open the report editor so a Recent report item will exist.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marković')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Dashboard' link to go to the dashboard page and check the Recent reports list (use element index 1683).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Dashboard link to open the dashboard and inspect the Recent reports list (then click the first recent report item).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the new-report (patient) form using the 'Novi nalaz' link so a report can be created and then verify the Recent reports list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Novi nalaz' link (index 1684) to open the new-report form so a report can be created (then will proceed to fill required fields and submit).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Dashboard link (index 1683) to return to the dashboard and inspect the 'Zadnji nalazi' (Recent reports) list for a created report item.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate directly to the dashboard page (http://localhost:3000/dashboard) to inspect the 'Zadnji nalazi' (Recent reports) list; if a recent report item is present, click the first item and then verify navigation to the report detail/editor view.\n        await page.goto(\"http://localhost:3000/dashboard\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Report').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Clicking the first item in the Recent reports list should open the in-app report detail/editor view and display 'Report', but the expected report editor text did not appear.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Verification could not be completed: the 'Zadnji nalazi' (Recent reports) section shows 'Nema sačuvanih nalaza' (no saved reports), so there is no recent report item to click. Extracted text from the section: \"Zadnji nalazi\\nNema sačuvanih nalaza\\nKada kreirate nalaz i preuzmete PDF ili Word, on će se pojaviti ovdje.\" Test progress: 4/7 steps completed (login steps done). Remaining steps that could not be run: click first Recent reports item; assert URL does not contain '/dashboard'; assert text 'Report' visible. Recommended next action if verification should continue: create and save a report (e.g., use 'Započni diktiranje' or upload a file, complete the patient form and finish/save the report) so it appears in 'Zadnji nalazi', then re-run the click + assertions. Stopping now per instruction.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771259056009868//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.205Z",
    "modified": "2026-02-16T16:24:16.143Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "30405704-d543-4a20-9fcb-a479d0a824a3",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC031-Dashboard quick action: start a new report",
    "description": "Verifies that the Dashboard \"New report\" quick action navigates to the new medical report page.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link to navigate to the login page (/login).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' (Login) link again to navigate to /login.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with the provided credentials and click the login button to sign in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'New report' quick action (Započni diktiranje) on the Dashboard to navigate to the new medical report page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div[1]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the sidebar 'Novi nalaz' link (alternative navigation) to navigate to /novi-nalaz and then verify the URL and page contents.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Novi nalaz').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that clicking the Dashboard 'New report' quick action navigates to the new medical report page (/novi-nalaz) and displays the 'Novi nalaz' heading, but the expected text was not visible\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Result: FAILED - The Dashboard \"New report\" quick action did not navigate to the new medical report page when clicked.\n\nDetails:\n- Quick action clicked: 'Započni diktiranje' (clicked once) — no navigation to /novi-nalaz occurred.\n- Alternative navigation: sidebar link 'Novi nalaz' was clicked and successfully navigated to http://localhost:3000/novi-nalaz.\n- Current page confirmed: URL = http://localhost:3000/novi-nalaz. Page shows header 'Novi nalaz' and the patient input form (fields: Ime, Prezime, JMBG, Datum rođenja, Telefon, Email, Adresa) and a 'Nastavi' button.\n\nConclusion and recommendation:\n- The quick action on the Dashboard does not perform the expected navigation; investigate the quick action click handler or routing logic. The sidebar link functions correctly as a workaround.\n\nTest status: The verification requested by the user is complete: quick action DOES NOT navigate as expected. Success=false.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258793370195//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.212Z",
    "modified": "2026-02-16T16:19:53.489Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "1066a7ff-dace-4515-a8b2-cee252dfb03e",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC032-Dashboard quick action: go to Patients",
    "description": "Verifies that the Dashboard \"Patients\" quick action navigates to the patient management page.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link on the landing page to open the login page (use element index 103).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' (Login) link again (index 103) to open the login page and wait for navigation to /login.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email field with example@gmail.com, fill the password field with password123, then click the 'Prijavite se' submit button.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Pacijenti' (Patients) quick action link in the dashboard sidebar (use element index 1221).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Pacijenti' quick action again (index 1221) to trigger navigation to the patient management page, then wait for the page to load.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # Assertions: verify navigation to the patient management page\n        await page.wait_for_url(\"**/pacijenti**\", timeout=10000)\n        assert \"/pacijenti\" in page.url, f\"Unexpected URL, expected '/pacijenti' to be part of {page.url}\"\n        # Verify the page shows the patients heading/text\n        elem = page.locator(\"text=Pacijenti\")\n        await elem.wait_for(state=\"visible\", timeout=5000)\n        assert await elem.is_visible(), \"The text 'Pacijenti' is not visible on the page\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258782362327//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.218Z",
    "modified": "2026-02-16T16:19:42.492Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "4ebf7c87-a99c-41ee-87b8-c1a289573ba8",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC033-Dashboard quick action: go to Settings",
    "description": "Verifies that the Dashboard \"Settings\" quick action navigates to the settings page.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) button to navigate to the login page (use element index 102).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the login page by clicking the 'Prijava' link/button to reach the /login form (click element index 102).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter the test credentials into the login form: type the email into the Email input (index 1000), then the password into the Lozinka input (index 1004), then click the Prijavite se button (index 1005).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Postavke' (Settings) quick action (index 1215) to navigate to the settings page, then verify the URL contains '/postavke' and that the page shows the text 'Settings' (or localized 'Postavke').\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258793743929//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.225Z",
    "modified": "2026-02-16T16:19:53.981Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "76daaa31-90e6-46ec-853d-240418fd2343",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC035-Template mode: select a template and verify template mode indicator is shown",
    "description": "Verifies the template workflow UI allows selecting a template and indicates template mode before dictation processing.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link/button to navigate to the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' (Login) control to navigate to the login page and load /login.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with the provided test credentials and submit the login form (enter email, enter password, click 'Prijavite se').\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Novi nalaz' link in the main navigation to open the new-report workflow (element index 1245).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Započni diktiranje' button in the 'Novi nalaz' card (element index 1281) to open the new-report/template workflow so the Template selector becomes available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div[1]/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Nastavi' (continue) button on the patient form to proceed to the template selection step so the Template selector becomes available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Nastavi' button on the patient form again (element index 1555) to proceed to the template selection step so the Template selector appears.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the required 'Ime' and 'Prezime' fields and click 'Nastavi' to proceed to the template selection step so the Template selector becomes available.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marković')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Kreiraj nalaz' button to start the create-report workflow so the Template selector becomes available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Kreiraj nalaz' card/button again (index 1502) to try to open the template-selection step so the Template selector becomes available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the required 'Datum rođenja' (date of birth) field with a valid date then click the 'Nastavi' button to attempt to advance to the template-selection step so the Template selector becomes available.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1980-01-01')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Ime and Prezime inputs so validation clears, then click 'Nastavi' to advance to the template-selection step so the Template selector becomes available.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marković')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Template mode').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected to see 'Template mode' indicating the template selection and template workflow was active before dictation processing, but the 'Template mode' indicator did not appear. This suggests the template selector did not become visible or the app did not enter template mode after selecting the Default template.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Verification result: FAILURE — Template selector and the text 'Template mode' were not found on the new-report page. Actions performed: logged in with example@gmail.com/password123, navigated to Dashboard, opened 'Novi nalaz', filled patient name (Marko Marković) and DOB, and attempted to proceed to template-selection multiple times (several 'Nastavi' and 'Kreiraj nalaz' clicks). Evidence: page URL is http://localhost:3000/novi-nalaz; search of page text returned no matches for 'Template', 'Template mode', 'Šablon', 'Default template', or 'Template selector'. Visible UI shows patient form and buttons such as 'Kreiraj nalaz' (index 1502) and 'Započni diktiranje' (index 1834), but no template chooser. Conclusion: The template-selection workflow cannot be verified because the template control is not present or not reachable from the current patient-form state. Suggested next steps (optional): 1) investigate why the patient-form save/transition is blocked (client validation or backend save failing), check client console/network for errors, or 2) confirm whether template-selection is implemented in another flow (e.g., after clicking 'Započni diktiranje' or in a separate settings area). Stopping as requested.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771259061062609//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.232Z",
    "modified": "2026-02-16T16:24:21.202Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "2dcf83b1-1781-4a8c-9a13-ae8a9cd0d991",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC036-Report History loads and displays a list of past reports",
    "description": "Verifies that the authenticated user can open Report History and see the reports list UI.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link to open the login page\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' link again to open the login page (navigate to /login) and wait for the page to load so email/password inputs become available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the login form: enter email and password, then click 'Prijavite se' to attempt login and wait for redirect to /dashboard.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Historija nalaza' in the main navigation to open the Report History page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Historija nalaza' link in the left navigation to open the Report History page (use element index 1198).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # -> Assert we were redirected to the dashboard after login\n        await page.wait_for_url(\"**/dashboard\", timeout=10000)\n        assert \"/dashboard\" in page.url, f\"Expected '/dashboard' in URL, got: {page.url}\"\n        \n        # -> Assert we were redirected to the Report History page after clicking 'Historija'\n        await page.wait_for_url(\"**/historija\", timeout=10000)\n        assert \"/historija\" in page.url, f\"Expected '/historija' in URL, got: {page.url}\"\n        \n        # -> Assert the text 'Historija' is visible on the page\n        locator = page.locator(\"text=Historija\")\n        await locator.wait_for(state=\"visible\", timeout=10000)\n        assert await locator.is_visible(), \"Expected text 'Historija' to be visible on the page\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258796154678//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.238Z",
    "modified": "2026-02-16T16:19:56.359Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "d066a6dd-ddc1-4017-80d4-b8c88ea1167b",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC038-Search with no matching results shows 'No results found' empty state",
    "description": "Verifies the UI displays a clear empty state when search matches no reports.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link on the homepage to navigate to the /login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' (Login) link on the homepage to open the /login page and wait for the login form to appear.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter the test email into the email input field (index 991) and then fill the password and submit the login form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Historija nalaza' in the main navigation to open the history page so the empty-state search behavior can be tested.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Historija nalaza' in the main navigation to open the history page so the empty-state search behavior can be tested.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type 'zzzz-no-such-report-term' into the search input (index 1433) and verify the empty-state text (e.g., 'Nema sačuvanih nalaza' or 'No results found') is visible, then finish the test.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('zzzz-no-such-report-term')\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        frame = context.pages[-1]\n        await page.wait_for_timeout(1000)\n        await frame.wait_for_selector(\"text=/No results found|Nema rezultata/i\", timeout=5000)\n        locator = frame.locator(\"text=/No results found|Nema rezultata/i\").nth(0)\n        assert await locator.is_visible(), \"Expected empty-state text 'No results found' or 'Nema rezultata' to be visible\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258870542001//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.245Z",
    "modified": "2026-02-16T16:21:10.678Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "7bde06ca-add2-40ee-8974-9ec4a6f1193d",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC040-Open a report from the list and view details page/section",
    "description": "Verifies selecting a report from history opens a detail view with report content visible.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link to open the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the login page by clicking the 'Prijava' link again and wait for the login form to appear.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter the test credentials into the email and password fields and click the 'Prijavite se' submit button to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Historija nalaza' link in the main navigation to open the history page (element index 1277).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Historija nalaza' link (index 1277) and wait for the history page to load so the report list can be checked. If no reports are present, report that selection cannot be performed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Detalji').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected that selecting a report from history would open the report detail view and display the 'Detalji' text, but the 'Detalji' element was not visible—the detail view did not open or the report content failed to render\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test cannot be completed: History page contains no saved reports to select. Steps performed: navigated to homepage, opened login, logged in with example@gmail.com / password123, navigated to 'Historija nalaza'. Current page shows the message 'Nema sačuvanih nalaza' and no report items are present. Therefore selection of a report and verification of the 'Detalji' view cannot be performed. Recommendation: create and save at least one report (or upload a test report) so the history list contains entries, then re-run this test to click the first report and verify the 'Detalji' content. Recorded actions and findings are included above.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258861199573//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.251Z",
    "modified": "2026-02-16T16:21:01.325Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "30840052-9577-4071-926f-5e29daf3d1da",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC041-Search input accepts special characters without breaking the page",
    "description": "Verifies the history page remains usable when the user enters punctuation or symbols in search.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) button in the header to navigate to the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' link/button in the header to navigate to the login page (element index 102).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the login form: enter example@gmail.com into the Email field (index 990), enter password123 into the Password field (index 994), then submit the form by clicking the 'Prijavite se' button (index 995).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Historija nalaza' link in the main navigation to open the history page (element index 1247).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Historija nalaza' link in the main navigation (element index 1247) to navigate to the history page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type the punctuation string '!@#()_+{}[]:;,.?' into the search field (input index 1492). After typing, verify the URL contains '/historija' and that the report list container (the area with 'Nema sačuvanih nalaza') is visible, then stop.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('!@#()_+{}[]:;,.?')\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # Assert the current URL contains \"/historija\"\n        assert \"/historija\" in page.url, f\"Expected '/historija' in URL, got: {page.url}\"\n        \n        # Assert the report list (empty state) is visible by checking for the \"Nema rezultata\" text\n        frame = context.pages[-1]\n        elem = frame.locator(\"text=Nema rezultata\").nth(0)\n        await elem.wait_for(state=\"visible\", timeout=5000)\n        assert await elem.is_visible(), \"Report list (empty state with 'Nema rezultata') is not visible\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Low",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258882191332//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.257Z",
    "modified": "2026-02-16T16:21:22.336Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "60395102-69d2-43e8-b63c-f3dc36c0e3cd",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC042-Long search term is handled gracefully and shows a stable results state",
    "description": "Verifies the UI remains stable when entering a very long search query.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link in the header to open the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' link in the header to open the login page (attempt 2).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the login form (email and password) and submit by clicking the 'Prijavite se' button.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Historija' (Historija nalaza) in the main navigation to open the history page and load the search input.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Historija nalaza' in the main navigation to open the history page and reveal the search input.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type the very long search query into the search input (index 1486) to verify UI stability when entering long input.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('this-is-a-very-long-search-term-intended-to-test-input-handling-and-ui-stability-1234567890')\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Low",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/177125891414295//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.264Z",
    "modified": "2026-02-16T16:21:54.295Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "0a82737b-2ef5-4337-b016-efd4159d6456",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC043-Add a new patient and verify it appears in the patient list",
    "description": "Verifies a logged-in user can create a patient record and see it listed afterward.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) button to open the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' (Login) button to open the login page (use element index 102).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with the provided test credentials and click the 'Prijavite se' (Sign in) button to attempt login.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Pacijenti' link in the main navigation to open the patients page (element index 1217).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Pacijenti' link in the main navigation to open the patients page and proceed to create a patient record.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Dodaj pacijenta' (Add patient) button to open the create-patient form, then fill and submit the form to create a new patient.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the patient form with test data and submit the form to create the new patient (then verify the new patient appears in the list). The next immediate action is to populate all fields and click 'Dodaj pacijenta' submit button.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestFirst')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestLast')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/form/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9876543210987')\n        \n        # -> Click the 'Dodaj pacijenta' submit button to create the new patient, then verify the new patient appears in the patients list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Search the patients list for the newly created patient (use the search input) and extract visible patient entries to confirm presence of TestFirst TestLast or JMBG 9876543210987.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestFirst')\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258991056102//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.270Z",
    "modified": "2026-02-16T16:23:11.168Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "2965a666-3936-413b-974d-9ecd4c59ebd1",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC044-Create patient from Patients page using valid details",
    "description": "Verifies the full add-patient workflow from the Patients page with valid input.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the login page by clicking the 'Prijava' (Login) link on the homepage.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' link to open the login page and reveal the email/password inputs so the login form can be filled.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with the test credentials and submit the login form (click 'Prijavite se'). Then wait for the resulting page state (redirect to /dashboard).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click on 'Pacijenti' in the main navigation to open the Patients page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Pacijenti' link in the main navigation to open the Patients page so the add-patient workflow can begin.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Dodaj pacijenta' (Add new patient) button to open the new patient form (element index 1572).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the patient form (Ime, Prezime, Datum rođenja, Telefon), then click 'Dodaj pacijenta' (Save patient). After that, verify that 'Test Patient A' appears in the patients list.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Patient A')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1980-05-20')\n        \n        # -> Type '+38761111222' into Telefon field and click 'Dodaj pacijenta' to submit the new patient form, then verify that 'Test Patient A' appears in the patients list.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/form/div[3]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('+38761111222')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # -> Assertions appended after the test actions\n        frame = context.pages[-1]\n        # Verify we were redirected to the dashboard\n        assert '/dashboard' in frame.url, f'Expected URL to contain /dashboard but got: {frame.url}'\n        # Verify the add-patient form/button is visible (localized text on page)\n        await frame.wait_for_selector('text=Dodaj pacijenta', timeout=5000)\n        assert await frame.locator('text=Dodaj pacijenta').is_visible(), 'Expected \"Dodaj pacijenta\" to be visible'\n        # Verify the newly added patient is visible in the patients list\n        await frame.wait_for_selector('text=Test Patient A', timeout=5000)\n        assert await frame.locator('text=Test Patient A').is_visible(), 'Expected \"Test Patient A\" to appear in the patients list'\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771259004408353//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.277Z",
    "modified": "2026-02-16T16:23:24.526Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "4d26cbab-42ef-456f-9e9d-fcb60cdc2d4f",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC045-Prevent saving when required patient name is missing",
    "description": "Verifies inline validation blocks saving if a required field is missing.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link in the header to open the login page (element index 103).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt to open the login page by clicking 'Prijava' again (element index 103).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the login form (email and password) and submit to sign in, then wait for redirect to /dashboard.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click on 'Pacijenti' in the main navigation to open the patients page (element index 1421).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Pacijenti' in the main navigation again to open the patients page (use element index 1421).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Dodaj pacijenta' (Add patient) button to open the new patient form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[1]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Clear the 'Ime' (Name) field (index 1737) to leave a required field empty and then attempt to save to trigger inline validation.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1990-01-01')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/form/div[3]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('test@example.com')\n        \n        # -> Click the 'Dodaj pacijenta' (Save patient) button (index 1778) to trigger validation, then verify that the texts 'Name' and 'required' are visible on the page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771259018152462//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.284Z",
    "modified": "2026-02-16T16:23:38.329Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "8a2d1d8b-3980-436d-a2ad-06345106b674",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC047-Open Patients page and verify list loads and is usable",
    "description": "Verifies the Patients page renders a visible patient list area and primary actions are available.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (login) link to navigate to the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' (login) link again (element index 108) to open the login page, then proceed to enter credentials and sign in.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter the provided test credentials into the email and password fields and click the 'Prijavite se' submit button to sign in (then wait for redirect to /dashboard).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Pacijenti' navigation item (index 1295) to open the Patients page, then verify the URL contains '/pacijenti' and that the patient list area and 'Add new patient' action are visible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Pacijenti' navigation item (index 1295) to navigate to the Patients page, then verify the URL contains '/pacijenti' and that the patient list area and 'Add new patient' action are visible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258882739927//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.290Z",
    "modified": "2026-02-16T16:21:22.876Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "25aeb24f-de6f-4643-989e-1370f3761868",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC049-Update doctor profile (name and specialization) successfully",
    "description": "Verifies a logged-in user can update doctor name and specialization and sees a visible success confirmation.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link to go to the /login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the visible 'Prijava' (Login) link to navigate to /login page (use element index 103).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with the provided credentials and submit the login form (enter example@gmail.com / password123, then click 'Prijavite se').\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Postavke' (Settings) link in the navigation to open the settings page (use element index 1326).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Postavke' (Settings) link in the navigation to open the settings page (use element index 1326).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter 'Dr. Test User' into the doctor name field and 'Kardiolog' into the specialization field, trigger blur/save, then search the page for a visible success confirmation message.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Dr. Test User')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Kardiolog')\n        \n        # -> Trigger a blur/click outside the input fields to force save, then re-scan the page for a visible success confirmation message.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/div[1]/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click outside the input fields to force save (click element index 1700), then scan the visible page text for success confirmation phrases (sačuvano, uspješno, Promjene su sačuvane, Spremljeno, Uspješno, etc.) and return any matches.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[5]/div[1]/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Sačuvaj postavke' (Save settings) button (element index 1741) to save changes, then re-scan the page for a visible success confirmation message.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771259070528692//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.296Z",
    "modified": "2026-02-16T16:24:30.735Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "f9d5953d-1c9e-4497-aa6b-85f53a4edc98",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC050-Save doctor profile changes and see confirmation",
    "description": "Verifies saving doctor profile changes shows a visible confirmation and the edited values remain visible after save.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link to navigate to the login page (element index 102).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt to navigate to the login page by clicking the 'Prijava' element again (index 102). If that fails, find an alternative navigation element or use go_to_url as last resort.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with the test credentials and submit the login form to reach /dashboard.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click on 'Postavke' (Settings) in the main navigation to open the profile/settings page\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Postavke (Settings) page by clicking the 'Postavke' link in the main navigation (element index 1274).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type 'Dr. Settings Save' into the doctor name input to update the profile (index 1523).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Dr. Settings Save')\n        \n        # -> Click the 'Sačuvaj postavke' (Save) button, wait for the page to update, then extract any visible confirmation message and the current value of the doctor name input (index 1523) and the current URL.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        frame = context.pages[-1]\n        await page.wait_for_timeout(1000)\n        assert \"/dashboard\" in page.url, f\"Expected '/dashboard' in URL but got {page.url}\"\n        \n        # Wait for a visible save confirmation (text: Sačuvano) after clicking Save\n        confirm = frame.locator('text=Sačuvano')\n        await confirm.wait_for(state='visible', timeout=5000)\n        assert await confirm.is_visible(), \"Save confirmation 'Sačuvano' is not visible after saving settings\"\n        \n        # Verify the doctor name input still contains the edited value\n        name_input = frame.locator(\"xpath=html/body/main/div[2]/div/div[1]/div[2]/div[1]/input\").nth(0)\n        await page.wait_for_timeout(500)\n        name_value = await name_input.input_value()\n        assert name_value == \"Dr. Settings Save\", f\"Expected doctor name to be 'Dr. Settings Save' but found '{name_value}'\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/177125895218291//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.303Z",
    "modified": "2026-02-16T16:22:32.352Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "490648c3-1c89-4e6c-8724-8f41be9477a2",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC052-Add a report category and save",
    "description": "Verifies a logged-in user can add a new report category and sees a confirmation after saving.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) button in the header to open the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the login page by clicking the 'Prijava' (Login) button in the header to reveal the login form.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with the provided test credentials and submit the login form (email: example@gmail.com, password: password123).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Postavke' (Settings) in the main navigation to open the settings page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Postavke' (Settings) link in the main navigation to open the settings page so the 'Add category' option becomes available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type 'Test Category A' into the 'Nova sekcija...' input (index 1687) and submit (press Enter) to add the new report category, then look for the confirmation message.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[4]/div[2]/div[6]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Category A')\n        \n        # -> Click 'Sačuvaj postavke' (Save settings) button to persist the new category and then wait for a confirmation message/toast.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # -> Assertions appended after actions\n        frame = context.pages[-1]\n        # Verify we were redirected to the dashboard\n        await expect(page).to_have_url(\"**/dashboard**\")\n        # Wait briefly for UI updates after save\n        await frame.wait_for_timeout(1000)\n        # Verify the newly added category is visible (case-insensitive)\n        new_category = frame.locator(\"text=/Test Category A/i\").nth(0)\n        await expect(new_category).to_be_visible(timeout=5000)\n        # Verify a confirmation/toast saying 'Sačuvano' is shown\n        confirmation = frame.locator(\"text=Sačuvano\").nth(0)\n        await expect(confirmation).to_be_visible(timeout=5000)\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258955537489//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.309Z",
    "modified": "2026-02-16T16:22:35.643Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "c3509d56-32d1-424b-b2e0-6199eb53dfae",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC053-Remove a report category and save",
    "description": "Verifies a logged-in user can remove an existing report category and sees a confirmation after saving.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link to navigate to the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' (Login) link to open the login page (element index 102).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with the test credentials and click 'Prijavite se' to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Submit the login form again to attempt to log in (use Enter key from the password field) and wait for redirect to /dashboard.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Postavke' (Settings) link in the left navigation to open the Settings page (use element index 1266).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Postavke' (Settings) link in the left navigation again to open the Settings page (use element index 1266).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Remove' (delete) control for the first report category (ANAMNEZA) in the 'Sekcije nalaza' list to remove it.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[4]/div[2]/div[1]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the delete control for the first report category (STATUS) to remove it, then click 'Sačuvaj postavke' (Save) and capture any confirmation message shown.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[4]/div[2]/div[1]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the alternative delete control for the first report category (use button index 1847) to remove it, then extract any visible confirmation/toast message text shown after the change.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[4]/div[2]/div[1]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258987358106//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.315Z",
    "modified": "2026-02-16T16:23:07.539Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "d77b1547-64b3-4729-8dca-f63de1ea06c0",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC054-Reorder report categories and verify reflected in New Report",
    "description": "Verifies a logged-in user can reorder report categories, save, and then see the updated ordering available when starting a new report.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link to go to the login page (use element index 103).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' (Login) link again to navigate to /login (attempt 2 of 2).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type the test credentials into the login form and submit (enter example@gmail.com in index 1081, password123 in index 1085, then click submit at index 1086).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Postavke' (Settings) in the left navigation to open the settings page (use element index 1364).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Postavke' (Settings) link in the sidebar (element index 1364) to open the settings page so categories can be reordered.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'move up' control for the second report category (STATUS) in the Sekcije nalaza list, then open 'Novi nalaz' to verify ordering.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[4]/div[2]/div[2]/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Sačuvaj postavke' (Save settings) button to persist the new ordering, then open 'Novi nalaz' to verify the updated ordering is used when starting a new report.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Return to Settings by clicking 'Postavke' in the sidebar (element index 1364) so the Save action can be retried and the new ordering persisted.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Settings page by clicking the 'Postavke' link in the sidebar (element index 1364) so the Save action can be retried.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Sačuvaj postavke' (index 2391) to persist the reordered sections, then open 'Novi nalaz' (index 1354) to verify the updated ordering.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open 'Novi nalaz' (index 1354) to load the new-report UI and inspect the order of sections so the updated ordering can be verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Load the new-report editor (ensure 'Kreiraj nalaz' create-mode is selected) and proceed (Nastavi) to the report editor so the sections ordering can be inspected/verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Nastavi' button on the New Report patient form to load the report editor and then verify the sections ordering (ensure STATUS moved up).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill patient 'Ime' and 'Prezime' fields and click 'Nastavi' to load the report editor so the sections ordering can be inspected/verified.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marković')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Reload the New Report flow and attempt to reach the report editor (click 'Novi nalaz' then 'Kreiraj nalaz', re-enter patient name/surname, click 'Nastavi') so the sections ordering can be extracted and verified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko')\n        \n        # -> Click 'Nastavi' to load the report editor, then extract the visible report sections order and confirm whether 'STATUS' is now above the previous first section.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open Settings by clicking 'Postavke' (index 1364) to re-check saved sections ordering in Settings, then proceed to a fresh New Report flow to attempt verification of ordering. Immediate action: click 'Postavke'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Postavke' (Settings) in the sidebar to open the Settings page so the saved ordering can be inspected (then extract the report categories order). Immediate action: click element index 1364.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Extract the current sections order from Settings (Sekcije nalaza) to confirm what is saved, then navigate to 'Novi nalaz' to start a fresh new-report flow for verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771259588205112//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.322Z",
    "modified": "2026-02-16T16:33:08.476Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "918b519e-3a13-4e3f-a242-ddfb52408c53",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC055-Verify settings save confirmation is visible after categories update",
    "description": "Verifies that after saving category changes, a visible confirmation message appears on the Settings page.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link to open the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt to open the login page by clicking the 'Prijava' element again (index 106). If login page appears, proceed with filling credentials and logging in.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type the email (example@gmail.com) into the Email field (index 1051), then fill the password and submit the form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Postavke' (Settings) in the main navigation to open the Settings page and then save category changes.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Postavke' (Settings) in the main navigation to open the Settings page (interactive element index 1574). After the page opens, locate and click the Save button and then verify the text 'Saved' is visible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the Save button (index 1979), wait briefly, then search the page for a visible confirmation message containing 'Saved' or localized variants like 'Sačuvano'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        frame = context.pages[-1]\n        # Wait for a visible confirmation message containing either 'Saved' (English) or 'Sačuvano' (localized)\n        msg = frame.locator(\"text=/Saved|Sa\\u010duvano/\").nth(0)\n        await msg.wait_for(state=\"visible\", timeout=10000)\n        assert await msg.is_visible(), \"Expected a visible confirmation message with text 'Saved' or 'Sačuvano'\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258955858567//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.328Z",
    "modified": "2026-02-16T16:22:36.001Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "59097830-81ae-40e5-8e2d-1377f6e017f3",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC056-Delete account flow - cancel in confirmation modal",
    "description": "Verifies that canceling the delete-account confirmation keeps the user on Settings and the account remains intact in the current session.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) button to open the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' button in the header to open the login page (/login).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with the provided test credentials and click the 'Prijavite se' submit button to log in (wait for redirect to /dashboard).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Postavke' (Settings) in the main navigation to open the Settings page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Postavke' (Settings) link in the sidebar to open the Settings page and wait for the page to load.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Delete account' (Obriši SVE moje podatke) button to open the confirmation modal, then verify the confirmation text and click Cancel.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[7]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Otkaži' (Cancel) button in the confirmation modal to dismiss it, then verify the app remains on the Settings page (/postavke) and the user session is still active (example@gmail.com visible).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/div/div[3]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258957379644//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.335Z",
    "modified": "2026-02-16T16:22:37.557Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "a6c87ed2-2c7d-46c5-a6b4-3cf06fe2588d",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC057-Export a finalized report as PDF from History",
    "description": "Verifies a user can open a finalized report from history and initiate PDF export from the report view.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link to go to the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' (Login) link on the homepage to open the /login page, then proceed to fill the login form with the provided credentials.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Enter the test email into the email field (input index 1060) and the password into the password field (input index 1064), then click the submit button (index 1065) to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click on 'Historija nalaza' in the main navigation to open the history page\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Historija nalaza' in the main navigation (attempt 2) to open the history page and then check for finalized reports.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the '+ Novi nalaz' link/button to create a new report so it can be finalized and saved to history (element index 1618). After the new report is created and saved, open it from Historija and click 'Export as PDF'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the new report editor by clicking '+ Novi nalaz' (index 1618) so a report can be created and finalized.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Novi nalaz patient form (all required fields) and click 'Nastavi' (index 2090) to proceed with creating the report so it can be finalized and saved to history.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marković')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1234567890123')\n        \n        # -> Click the '+ Novi nalaz' button on the Historija page to open the new-report editor so the remaining form steps can be completed (index 2231).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the new-report editor by clicking '+ Novi nalaz' on the Historija page (index 2231). After page loads, fill remaining report details and click 'Nastavi' (index 2090) to proceed toward finalizing and saving the report.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Nastavi' button to proceed from the patient form to the report creation flow (click index 2610). After that, finalize/save the report so it appears in Historija, open the finalized report, and click 'Export as PDF'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the new-report editor by clicking 'Novi nalaz' in the left navigation (index 2540) so the report creation flow can be completed (then click 'Nastavi' and finalize/save the report).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the center-page '+ Novi nalaz' button (index 2728) to open the new-report editor so the patient form and 'Nastavi' can be completed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the visible 'Nastavi' button (index 3262) to proceed to the report creation flow.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the '+ Novi nalaz' button (index 3380) to open the new-report editor so the report creation flow can be completed (then click 'Nastavi' and finalize/save the report).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the '+ Novi nalaz' button to open the new-report editor so the report creation flow can be completed (use element index 3380).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the visible 'Nastavi' button (index 3910) to proceed to the report creation flow.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the '+ Novi nalaz' button (index 4028) to open the new-report editor so the report creation flow can be completed (then fill details and click 'Nastavi').\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the '+ Novi nalaz' button (index 4028) on the Historija page to open the new-report editor so the report creation flow can be completed (then proceed to 'Nastavi', finalize/save, open from Historija and export as PDF).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the new-report editor by clicking '+ Novi nalaz' so the report creation flow can be started (use index 4704).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the new-report editor using the left navigation 'Novi nalaz' link (index 4516) so the report creation flow can be started from a different entry point.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the visible 'Nastavi' button (index 4814) to proceed to the report creation flow.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Kreiraj nalaz' to start creating the report (then finalize/save it so it appears in Historija, open it from Historija, and click 'Export as PDF'). Next immediate action: click index 4771.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Re-enter the patient name/surname/JMBG (to clear validation) and click 'Nastavi' to proceed with creating the report.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marković')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1234567890123')\n        \n        # -> Click the 'Nastavi' button on the Novi nalaz patient form (index 4814) to proceed into the report creation flow.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Kreiraj nalaz' to create the report so the flow can proceed toward finalization and saving to Historija (immediate action).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Date of Birth field (Datum rođenja) and click 'Nastavi' to attempt to continue and create/finalize the report so it can be saved to Historija.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1990-01-01')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Kreiraj nalaz' to create/finalize the report so it will be saved to Historija (then open Historija and open the finalized report to export as PDF).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771259572369244//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.341Z",
    "modified": "2026-02-16T16:32:52.666Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "00e21916-a2bf-41ee-8151-39f6bf497d54",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC058-Start PDF export from a finalized report opened from New Report page",
    "description": "Verifies a user can access an existing finalized report context from the New Report area and start PDF export.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) button to open the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' (Login) button again to open the login page\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email field on the /login page with the test email (example@gmail.com) as the next immediate action.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click on the 'Novi nalaz' link in the main navigation to open the New Report page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Novi nalaz' link in the sidebar to navigate to /novi-nalaz and then verify the URL contains '/novi-nalaz'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Ažuriraj postojeći' option to open the UI for finding/updating an existing finalized report, so an existing report can be opened.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type a short search query into the patient search input to reveal existing patients/reports so an existing finalized report can be opened.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('a')\n        \n        # -> Click the matching patient entry (TestFirst TestLast) to open that patient's existing finalized report list so a finalized report can be opened and PDF export started.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Change the selected patient (click 'Promijeni') to search for a different patient who may have existing finalized reports.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type a new search query into the patient search input to find a different patient that may have existing finalized reports (use the input at index 1973).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('marko')\n        \n        # -> Click the patient entry at index 2129 (Marko Marković) to open that patient's existing report list so a finalized report can be opened and PDF export started.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Promijeni' (element index 2174) to return to the patient search UI so a different patient can be searched for who may have existing finalized reports.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type a new search query into the patient search input (index 2209) to reveal different patients who may have existing finalized reports.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('s')\n        \n        # -> Type a new search query into the patient search input (index 2209) to find a different patient who may have existing finalized reports (try 'ivan').\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ivan')\n        \n        # -> Click the 'Historija nalaza' link in the left sidebar to look for existing finalized reports (element index 1320).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt navigation again by clicking the 'Historija nalaza' link in the left sidebar (index 1320). If it navigates, locate a finalized report and start PDF export; if still no navigation, fallback to alternative path.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=PDF Export Started').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to open an existing finalized report from the New Report area and start a PDF export, but the expected 'PDF Export Started' indicator did not appear—either the report was not opened or the export did not initiate.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test result: FAILURE — The test cannot complete because no existing finalized reports were found. Steps executed: navigated to /login and logged in with example@gmail.com / password123, navigated to /novi-nalaz, attempted to open existing reports for multiple patients, then opened 'Historija nalaza' (/historija). Observation: the Historija page displays 'Nema sačuvanih nalaza' (no saved reports), so there is no finalized report to open and no way to start a PDF export. Recommended next actions: (1) create and download a report (PDF/Word) in the app to cause it to appear in Historija, then re-run this test; or (2) seed the database with at least one finalized/saved report for the test account and re-run. Test outcome: success=false.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771259180513053//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.348Z",
    "modified": "2026-02-16T16:26:20.671Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "4a98c6f2-c953-4365-85b2-98bb3433c260",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC059-Export a finalized report as Word when a template is available",
    "description": "Verifies Word export action is available and can be initiated for a finalized report that has a stored .docx template.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link to open the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the login page by clicking the 'Prijava' link (use element index 101).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email field with example@gmail.com, fill the password field with password123, then click the 'Prijavite se' submit button to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Historija nalaza' in the main navigation to open the history page and search for a finalized report that has a stored .docx template.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Historija nalaza' in the sidebar to open the history page and look for finalized reports that have a stored .docx template.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click '+ Novi nalaz' to create a new report so a finalized report with a Word (.docx) template can be produced and the Export as Word action can be tested.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the new report form by clicking '+ Novi nalaz' so a new report can be created and finalized (click element index 1434).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Try to allow SPA to finish loading; if no content appears, navigate to the history page to continue creating or checking reports.\n        await page.goto(\"http://localhost:3000/historija\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Novi nalaz' link in the sidebar (use element index 2236) to open the new-report form so a report can be created and finalized for Word export testing.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Word Export Initiated').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to initiate the 'Export as Word' action for a finalized report with a stored .docx template, but the expected confirmation text 'Word Export Initiated' did not appear, indicating the export could not be started or the success message was not shown.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test completed up to verification step but cannot verify Word export. Summary of findings and blocking issues:\n- Login: succeeded using example@gmail.com / password123; redirected to /dashboard confirmed.\n- History: opened (index 2244 / 2280 present). Page shows \"Nema sačuvanih nalaza\" (no saved reports).\n- No finalized reports were found in history, so 'Export as Word' cannot be located or initiated.\n- Attempted to create a new report via '+ Novi nalaz' (clicked twice: earlier index 1434, then sidebar link index 2236 / + button index 2280). The /novi-nalaz route loaded but SPA content/new-report form did not render (empty page), preventing creation and finalization of a report.\n- Because no finalized report exists and new-report creation is blocked by SPA rendering failure, the Word export action cannot be verified or initiated.\nRecommended next steps to complete the test:\n1) Fix SPA/new-report rendering at /novi-nalaz so the new-report form can be used; OR\n2) Pre-populate the test account (example@gmail.com) with at least one finalized report that includes a stored .docx template in Historija; OR\n3) Provide backend access or a test fixture to create a finalized report programmatically.\nWhen one of the above is done, re-run: navigate to Historija, select the finalized report that indicates a Word/DOCX template, and click 'Export as Word' to verify the export action.\nCurrent status: Word export not verified. Blocking issue: no saved reports + new-report form failing to render. Success=false.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771259000917347//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.354Z",
    "modified": "2026-02-16T16:23:21.175Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "2daad030-53f3-4ab1-9f8c-7aeb2587cbc2",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC060-Copy report text for HIS and see 'Copied!' feedback",
    "description": "Verifies the HIS copy action shows visible success feedback after clicking copy.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link to navigate to the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' link (index 103) to navigate to the login page (/login).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the login form (email + password) and click the submit button to log in (attempt to reach /dashboard).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click on 'Historija nalaza' in the main navigation to open the history page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Historija nalaza' link to open the history page and then locate a finalized report to open (next immediate action: click element index 1342).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Create or open a report so the 'Copy for HIS' button can be tested. Click the '+ Novi nalaz' link (index 1585) to start creating a new report.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the '+ Novi nalaz' link to start creating a new report (index 1585).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the patient form fields on /novi-nalaz and click 'Nastavi' to create the report (this should proceed to the next report creation step).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marković')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[2]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1234567890123')\n        \n        # -> Click the 'Nastavi' (Continue) button to proceed with report creation (index 2203).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Proceed into report creation by selecting the creation method ('Kreiraj nalaz') to move to the next step of creating and saving the report (click element index 2160).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[1]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Nastavi' (Continue) button to proceed to the next report creation step (attempt #2).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the Date of birth field (index 2407) and submit the form using Enter to attempt to proceed to the next report creation step without clicking the 'Nastavi' button again.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1985-05-20')\n        \n        # -> Fill the patient's phone, email and address fields, then submit the form using Enter to attempt to proceed to the next report creation step.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[3]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('+387 61 123 456')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[3]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('pacijent@example.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Ul. Maršala Tita 1, 71000 Sarajevo')\n        \n        # -> Re-enter the patient name fields to clear any validation state and attempt to proceed to the next step (click 'Nastavi'). If this fails, try alternative navigation to create/save the report so the 'Copy for HIS' action can be tested.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marko')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[1]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Marković')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[2]/div/div/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Historija nalaza' link (index 2135) to check if the report was saved and appears in history.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Historija nalaza' sidebar link (index 2135) to check if a saved report appears in history. If history is empty, report inability to complete 'Copy for HIS' verification.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the sidebar 'Novi nalaz' link (index 2133) to open the report creation page using a different element and attempt report creation again.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Copied!').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test was verifying that clicking the 'Copy for HIS' button on a finalized report would display a visible 'Copied!' confirmation, but the 'Copied!' success feedback did not appear.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Final status: FAILED to verify the 'Copy for HIS' success feedback. Reason: no finalized/saved report exists in Historija to open and test; attempts to create/save a report failed with the UI error 'Greška pri čuvanju. Pokušajte ponovo.' Actions taken (chronological): navigated to /login and logged in with example@gmail.com/password123; opened Historija; attempted to create a new report via '+ Novi nalaz' (two UI entry points); filled all required patient fields; attempted submission using 'Nastavi' and Enter multiple times; observed save error and validation messages; revisited Historija which shows no saved reports. Because of the save failure, the 'Copy for HIS' button could not be located or clicked and therefore 'Copied!' could not be verified.\nRecommendations to complete the test:\n- Fix the backend/save flow causing 'Greška pri čuvanju. Pokušajte ponovo.' and then re-run the same steps; OR\n- Provide a pre-saved/finalized report in Historija to open and test the copy button; OR\n- Allow creating a report through an API or test fixture so the UI has at least one saved report to open.\nIf the user wants, next actions available: retry report creation after backend fix, or attempt to seed a report via API (requires endpoint/credentials), or proceed if a sample report is provided. No further UI actions are performed now.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771259307741736//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.360Z",
    "modified": "2026-02-16T16:28:27.950Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "3be0af3d-0fb0-4caa-afae-40b0f4be335b",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC063-Authenticated user is redirected away from /login to /dashboard",
    "description": "Verifies middleware prevents logged-in users from accessing the login page and redirects them to the dashboard.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (login) link/button to navigate to the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' link/button to navigate to the login page (attempt 2).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type example@gmail.com into the email field\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate to /login while logged-in to verify middleware redirects back to /dashboard (attempt to access /login and expect immediate redirect).\n        await page.goto(\"http://localhost:3000/login\", wait_until=\"commit\", timeout=10000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Dashboard').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Middleware should redirect an authenticated user away from /login to /dashboard, but the dashboard did not appear after navigating to /login while logged in.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Result: Middleware did NOT prevent access to the login page for authenticated users. Evidence: current URL is http://localhost:3000/login after attempting to navigate to /login while already authenticated. The login form inputs are present (email input index 1362, password input index 1363, submit button index 1366). Test plan status: 6/7 steps completed; final verification (step 7) failed. Recommendation: verify server-side/auth middleware that should detect an authenticated session and perform a redirect to /dashboard. Check session detection logic, client redirect code, or any route guards that should run on /login. Test concluded with failure (middleware did not redirect).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258903005239//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.366Z",
    "modified": "2026-02-16T16:21:43.130Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "e8c4e613-f194-4503-b03d-1e9bb2af9ec5",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC064-Authenticated user can access a protected route after login (no redirect to /login)",
    "description": "Verifies that after successful login, navigating to a protected page stays within authenticated area.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' element (index 103) to open the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt to open the login page by clicking the 'Prijava' element (index 103) so the login form appears; after navigation, fill email and password and submit.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the login form: enter example@gmail.com into email (index 1061), enter password123 into password (index 1065), then click the submit button (index 1066) to attempt login and trigger navigation to the dashboard.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Novi nalaz' link (index 1296) to navigate to the protected page, then verify the URL contains '/novi-nalaz'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Novi nalaz' link (index 1296) to navigate to the protected page so the URL can be verified to contain '/novi-nalaz'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # Verify we were redirected to the dashboard after login (wait up to ~10s)\n        for _ in range(20):\n            if '/dashboard' in page.url:\n                break\n            await page.wait_for_timeout(500)\n        assert '/dashboard' in page.url, f\"Expected '/dashboard' in URL after login, got: {page.url}\"\n        \n        # Verify navigation to the protected page '/novi-nalaz' (wait up to ~10s)\n        for _ in range(20):\n            if '/novi-nalaz' in page.url:\n                break\n            await page.wait_for_timeout(500)\n        assert '/novi-nalaz' in page.url, f\"Expected '/novi-nalaz' in URL after navigating to protected page, got: {page.url}\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Medium",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/177125894505848//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.372Z",
    "modified": "2026-02-16T16:22:25.169Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "467bc29c-c790-4499-9356-47dc6e7bc430",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC065-Accept GDPR consent on first-time app load unlocks app usage",
    "description": "Verifies the GDPR consent modal blocks usage until the user accepts, after which the user can proceed to authenticated app areas.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' link (element index 102) to navigate to the login page (/login).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Attempt navigation to the login page by clicking the 'Prijava' link again (index 102). After click, inspect the page for login form fields and any GDPR consent modal.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields with the provided credentials (example@gmail.com / password123) and click the 'Prijavite se' submit button to attempt login, then observe navigation and any GDPR modal.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=GDPR').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test expected the GDPR consent modal (text 'GDPR') to appear after login to block usage until the user accepts, but the GDPR text/modal was not visible, so consent could not be accepted and the flow to authenticated areas failed.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test summary:\n- Login with provided credentials succeeded and application redirected to /dashboard.\n- GDPR consent modal or any text containing 'GDPR' was not found on the dashboard page; no 'Prihvatam' (Accept) button available.\n- Because the GDPR modal is not present, the requirement 'GDPR consent modal blocks usage until acceptance' cannot be validated in this session.\nRecommendations:\n- If the GDPR modal is expected, clear site cookies/local storage or use a fresh/incognito session and retry the test.\n- Alternatively, reset the GDPR flag in the backend or test environment to force the modal to appear and repeat the verification.\nResult: test could not confirm GDPR blocking behavior (success=false).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258895745126//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.379Z",
    "modified": "2026-02-16T16:21:35.891Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "358e50c3-630a-49bc-b36c-c6e6539a6bb6",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC068-Closing GDPR consent modal (without acceptance) keeps the app blocked",
    "description": "Verifies that attempting to close the consent modal without accepting does not unlock the app.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' link on the homepage to open the login page (index 104). After navigation, fill in email and password.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' link (index 104) on the homepage to navigate to the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields on the login page then submit the form (enter credentials and click 'Prijavite se').\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open 'Postavke' (Settings) to look for GDPR/consent controls or to trigger the consent modal, then search that page for GDPR text or 'Prihvatam'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open 'Postavke' (Settings) to find GDPR/consent modal, then search the settings page for text 'GDPR'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Prihvatam').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that closing the GDPR consent modal without accepting does NOT unlock the app — the consent modal and its 'Prihvatam' (Accept) button should still be visible, but 'Prihvatam' was not found.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test result: FAILED to verify the requested behavior because the GDPR consent modal could not be found on the application pages inspected.\n\nSummary of findings:\n- Authentication: Login completed using provided credentials (example@gmail.com / password123) and redirected to the app.\n- 'GDPR' text: Located on /postavke (Settings) as a static settings section titled 'Privatnost i GDPR'. This is not a modal.\n- 'Prihvatam' (Accept) text: Not found on dashboard or settings (search attempted twice).\n- Consent modal close 'X': No consent modal or close button present on any inspected page, so close action could not be attempted.\n\nConclusion:\n- Consent modal not present on dashboard or settings; therefore the step to attempt closing the consent modal without accepting could not be executed and the verification that closing without accepting does not unlock the app cannot be completed.\n\nRecommended next steps to reproduce the consent modal (suggestions):\n- Reproduce initial state that triggers the consent modal (clear local storage/cookies, use a fresh browser session/incognito, or reset any environment flags that show the modal).\n- After reproducing the modal, repeat the test: attempt to close with the 'X' (without accepting) and verify whether the app remains locked/unlocked.\n\nCompleted steps (so far): 5/8. Remaining steps blocked by missing consent modal.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771259035765278//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.385Z",
    "modified": "2026-02-16T16:23:55.898Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "3d072a34-62d3-443a-91c2-21d84c8fa52a",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC069-One-click data deletion from Settings clears data and returns to consent onboarding state",
    "description": "Verifies the user can delete all local data from Settings and is returned to an initial consent-required state afterward.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link to navigate to the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' (Login) link on the homepage to navigate to the login page (use interactive element index 105).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type the email into the email input (index 1023) and proceed to enter password and submit the form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Postavke' (Settings) navigation item to open Settings page (step 5). After navigation, verify the URL contains '/postavke' and proceed to locate the 'Obriši sve moje podatke' button.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Postavke' (Settings) navigation item to open the Settings page (use interactive element index 1288).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the delete data button in Settings to trigger the confirmation dialog, then verify that the confirmation text 'Potvrdi' is visible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[6]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the currently open history-delete modal by clicking 'Otkaži' (Cancel) so the 'Obriši SVE moje podatke' button can be clicked next.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/div/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Obriši SVE moje podatke' button (index 1648) to open the delete-all-data confirmation, then verify the confirmation text 'Potvrdi' is visible on the page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[7]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type 'OBRIŠI' into the confirmation input (index 1831) and click the confirm button 'Obriši sve i odjavi me' (index 1832) to perform deletion and trigger logout. After that, verify the app returns to the initial consent-required state.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('OBRIŠI')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/div/div[3]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Obriši SVE moje podatke' button (index 1648) to re-open the delete-all-data confirmation modal.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[7]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type 'OBRIŠI' into the confirmation input (index 1892) and click the confirm button to delete all data and trigger logout; then verify application returns to initial consent-required state.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('OBRIŠI')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/div/div[3]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test result: FAILURE — could not complete the delete-all-data flow. Summary: The Settings page and delete modal were reached successfully and the required confirmation token 'OBRIŠI' was entered (two attempts), but the confirm action to actually delete data ('Obriši sve i odjavi me') was not clicked. Observed behavior: each time after typing 'OBRIŠI' the Cancel ('Otkaži') button was clicked instead of the confirm button, so no deletion or logout occurred. Required remaining steps to finish the test manually or by another agent run: 1) Click 'Obriši SVE moje podatke' (Settings button). 2) In the confirmation modal, type exactly OBRIŠI into the confirmation input. 3) Click the confirm button labeled 'Obriši sve i odjavi me' to perform deletion and logout. 4) Verify the application returns to the initial consent-required state (e.g., homepage shows consent prompt or login state cleared). Notes and constraints: - Confirmation typing was attempted twice and both attempts ended with Cancel; rules prohibit repeating identical failing actions more than twice. - Confirm button index observed earlier in the session was 1832 (modal-generated); confirmation input index observed earlier was 1892/1831 in prior steps. If rerunning the flow, after step 2 ensure the confirm button (label 'Obriši sve i odjavi me') is clicked rather than Cancel. Because the final confirm was not executed, success=false.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771259129307332//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.392Z",
    "modified": "2026-02-16T16:25:29.427Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "ed78b4de-391f-426d-a650-73fdb66330e7",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC070-Confirming data deletion clears consent and shows GDPR modal again",
    "description": "Verifies that confirming deletion completes the action and the GDPR consent modal reappears, indicating consent state was cleared.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) button to open the login page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' (Login) link/button on the homepage to open the login page (navigate to /login).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields and submit the login form to sign in (will navigate to dashboard).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Postavke' (Settings) navigation item to open the settings page.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Postavke' (Settings) link on the dashboard to open the settings page so the 'Obriši sve moje podatke' option can be accessed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Obriši SVE moje podatke' (Delete ALL my data) button to open the confirmation modal so the deletion can be confirmed.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[7]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type 'OBRIŠI' into the confirmation input and click the confirm button to perform deletion, then verify the GDPR consent modal reappears.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('OBRIŠI')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/div/div[3]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Re-open the deletion modal, type 'OBRIŠI' into the confirmation input, and click the confirm button to perform deletion (then verify GDPR modal appears). The next immediate actions will reopen the modal and confirm deletion.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[7]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Type 'OBRIŠI' into confirmation input (index 2002) and submit confirmation without clicking the Cancel button (use Enter key) to perform deletion (then verify GDPR modal appears).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('OBRIŠI')\n        \n        # -> Click the confirm button in the deletion modal (element index 2004), wait for the page to update, then verify that text 'GDPR' is visible (indicating GDPR consent modal/state reappeared).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/main/div[2]/div/div[8]/div/div[3]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # -> Verify text \"GDPR\" is visible (GDPR consent modal reappeared)\n        await frame.wait_for_selector(\"text=GDPR\", timeout=10000)\n        visible = await frame.locator(\"text=GDPR\").is_visible()\n        assert visible, \"Expected text 'GDPR' to be visible after confirming deletion (GDPR consent modal should reappear)\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "High",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771259102631092//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.398Z",
    "modified": "2026-02-16T16:25:02.784Z"
  },
  {
    "projectId": "aeb3c6a0-1720-4451-83ff-6d797f829b65",
    "testId": "dd99d08c-bc8b-4e4f-964b-fa9383272d31",
    "userId": "0408c4d8-1061-7027-80ba-052582f55498",
    "title": "TC072-After accepting GDPR consent, navigating within the app does not show the consent modal again in-session",
    "description": "Verifies that once consent is accepted, the user can navigate to another authenticated page without being re-blocked by the consent modal during the same session.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Click the 'Prijava' (Login) link to navigate to the login page (/login).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Prijava' link (index 102) to navigate to the login page (/login).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/nav/div/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields then submit the login form (input into index 1084 and 1088, then click index 1089).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[1]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[2]/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Historija nalaza' navigation item (index 1355) to confirm navigation to the history page without being blocked by a consent modal.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Historija nalaza' navigation item (index 1355) to attempt navigation to the history page and then verify the URL contains '/historija'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/aside/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # -> Final assertions added according to the test plan\n        await page.wait_for_timeout(1000)\n        content = await frame.locator('body').inner_text()\n        assert 'GDPR' in content, 'Expected \"GDPR\" text to be visible on the page.'\n        assert '/historija' in frame.url, f\"Expected URL to contain '/historija' but got: {frame.url}\"\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "priority": "Low",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/0408c4d8-1061-7027-80ba-052582f55498/1771258962738991//tmp/test_task/result.webm",
    "created": "2026-02-16T16:15:25.404Z",
    "modified": "2026-02-16T16:22:42.858Z"
  }
]
