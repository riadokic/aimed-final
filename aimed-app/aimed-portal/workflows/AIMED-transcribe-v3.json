{
  "name": "AIMED-transcribe",
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": true,
    "saveDataSuccessExecution": "none",
    "saveDataErrorExecution": "none"
  },
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Whisper Transkripcija",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Whisper Transkripcija": {
      "main": [
        [
          {
            "node": "Build Claude Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Claude Request": {
      "main": [
        [
          {
            "node": "Claude - JSON Extraction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Claude - JSON Extraction": {
      "main": [
        [
          {
            "node": "Parse JSON Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse JSON Response": {
      "main": [
        [
          {
            "node": "Respond with JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "AIMED-transcribe",
        "responseMode": "responseNode",
        "options": {
          "binaryPropertyName": "audio"
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [-464, 336],
      "id": "e44f90a3-6837-443d-a983-b40d00e322e5",
      "name": "Webhook",
      "webhookId": "aimed-transcribe-v2"
    },
    {
      "parameters": {
        "resource": "audio",
        "operation": "transcribe",
        "binaryPropertyName": "audio0",
        "options": {
          "language": "hr"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 2.1,
      "position": [-192, 336],
      "id": "56123641-206e-45d4-9a05-15554761de20",
      "name": "Whisper Transkripcija"
    },
    {
      "parameters": {
        "jsCode": "// Zero-Hallucination Prompt Builder v4\n// Strict section enforcement, admin blacklist, temperature 0, JSON-only output\n\nconst transcript = $json.text;\n\n// Read form fields from original Webhook body\nconst webhookData = $('Webhook').item.json.body || {};\nconst mode = webhookData.mode || 'new';\n\nlet preferredSections;\ntry {\n  preferredSections = typeof webhookData.preferred_sections === 'string'\n    ? JSON.parse(webhookData.preferred_sections)\n    : webhookData.preferred_sections;\n} catch {\n  preferredSections = null;\n}\n\nconst defaultSections = ['ANAMNEZA', 'STATUS', 'DIJAGNOZA', 'TERAPIJA', 'PREPORUKE'];\nconst sections = (preferredSections && Array.isArray(preferredSections) && preferredSections.length > 0)\n  ? preferredSections\n  : defaultSections;\n\nconst sectionList = sections.map(s => `\"${s}\"`).join(', ');\n\n// Administrative data blacklist — these are handled by UI, never by AI\nconst ADMIN_BLACKLIST = [\n  'PODACI O PACIJENTU', 'DATUM PREGLEDA', 'IME I PREZIME', 'JMBG',\n  'DATUM ROĐENJA', 'ADRESA', 'KONTAKT', 'BROJ PROTOKOLA',\n  'MATIČNI BROJ', 'DATUM NALAZA', 'ZAKLJUČAK'\n];\nconst blacklistStr = ADMIN_BLACKLIST.map(s => `\"${s}\"`).join(', ');\n\nlet existingData = null;\nlet existingReport = null;\n\nif (mode === 'update') {\n  try {\n    existingData = typeof webhookData.existing_data === 'string'\n      ? JSON.parse(webhookData.existing_data)\n      : webhookData.existing_data;\n  } catch {}\n  existingReport = webhookData.existing_report || null;\n}\n\n// Build prompt based on mode\nlet prompt;\n\nif (mode === 'update' && (existingData || existingReport)) {\n  // UPDATE MODE\n  const existingJson = existingData\n    ? JSON.stringify(existingData, null, 2)\n    : null;\n\n  prompt = `Ti si medicinski urednik za ljekarske nalaze u Bosni i Hercegovini.\n\nZADATAK:\nDobit ćeš postojeći nalaz (kao JSON) i novi audio transkript s izmjenama. Primijeni SAMO izmjene koje su eksplicitno diktirane. Sve ostalo ostavi NETAKNUTO.\n\nIZLAZ:\nVrati ISKLJUČIVO validan JSON objekat. Tvoj odgovor MORA početi sa { i završiti sa }. NIKAKAV drugi tekst, objašnjenje, komentari, ili markdown blokovi.\n\nDOZVOLJENE SEKCIJE (ključevi u JSON-u): ${sectionList}\n\nSTROGA PRAVILA — NULTA TOLERANCIJA NA HALUCINACIJE:\n1. SAMO diktirane izmjene: Ako transkript ne pominje neku sekciju, ostavi je identičnu originalu.\n2. ZABRANJEN NOVI SADRŽAJ: Ne smišljaj, ne dopunjuj, ne \"poboljšavaj\" tekst koji nije diktiran.\n3. ZABRANJENE SEKCIJE: Nikada ne generiši ove ključeve: ${blacklistStr}. Ove podatke popunjava UI aplikacija.\n4. Ako transkript kaže \"promijeni\", \"dodaj u\", \"obriši\" — primijeni to na tu sekciju.\n5. BEZ PRAZNIH SEKCIJA: Ako sekcija u originalu ima sadržaj a transkript je ne mijenja, zadrži original. Ako je prazna i transkript je ne pominje, NE uključuj je.\n\nMEDICINSKO FORMATIRANJE:\n- Ispravi gramatičke i pravopisne greške u NOVOM diktatiranom sadržaju.\n- Standardiziraj medicinske termine prema bh./hrvatskom standardu, latinska terminologija za dijagnoze.\n- TAČNOST BROJEVA: Doze, mjerenja prepiši identično. Nemoj zaokruživati.\n\nAko primjetiš medicinsku nelogičnost, dodaj ključ \"_napomene\" sa kratkim opisom.\n\nPOSTOJEĆI NALAZ (JSON):\n${existingJson || existingReport}\n\n---\n\nTRANSKRIPT IZMJENA:\n${transcript}`;\n\n} else {\n  // NEW MODE\n  prompt = `Ti si medicinski asistent za transkripciju ljekarskih nalaza u Bosni i Hercegovini.\n\nZADATAK:\nPrimi transkribirani tekst sa glasovnog snimka ljekara. Organizuj diktirani sadržaj u medicinske sekcije i vrati kao JSON.\n\nIZLAZ:\nVrati ISKLJUČIVO validan JSON objekat. Tvoj odgovor MORA početi sa { i završiti sa }. NIKAKAV drugi tekst, objašnjenje, komentari, ili markdown blokovi.\n\nDOZVOLJENE SEKCIJE (ključevi u JSON-u): ${sectionList}\n\nSTROGA PRAVILA — NULTA TOLERANCIJA NA HALUCINACIJE:\n1. SAMO DIKTIRANI SADRŽAJ: Ako ljekar NIJE diktirao sadržaj za neku sekciju, NE uključuj tu sekciju u JSON. Ne inicijaliziraj je sa praznim stringom, \"N/A\", ili bilo čim drugim.\n2. ZABRANJEN IZMIŠLJENI SADRŽAJ: Ne dopunjuj, ne pretpostavljaj, ne generiši tekst koji ljekar nije izgovorio.\n3. ZABRANJENE SEKCIJE: Nikada ne generiši ove ključeve: ${blacklistStr}. Ove podatke popunjava UI aplikacija, a ne AI.\n4. JSON SADRŽI SAMO sekcije za koje postoji diktirani sadržaj u transkriptu.\n5. Ako transkript ne sadrži dovoljno informacija za ijednu sekciju, vrati prazan JSON objekat: {}\n\nMEDICINSKO FORMATIRANJE:\n- Ispravi gramatičke i pravopisne greške.\n- Standardiziraj medicinske termine prema bh./hrvatskom standardu.\n- Latinska terminologija za formalne dijagnoze ili ako ljekar izgovori latinski termin.\n- TAČNOST BROJEVA: Doze, mjerenja i laboratorijske vrijednosti prepiši identično. Nemoj zaokruživati.\n- Brojeve numerički (500mg), datume kao DD.MM.GGGG., formalan medicinski stil.\n- VELIKA SLOVA za ključeve (naslove sekcija) u JSON-u.\n\nAko primjetiš medicinsku nelogičnost ili kontradikciju, dodaj ključ \"_napomene\" sa kratkim opisom.\n\n---\n\nTRANSKRIPCIJA:\n\n${transcript}`;\n}\n\nconst requestBody = {\n  model: 'claude-haiku-4-5-20251001',\n  max_tokens: 4096,\n  temperature: 0,\n  messages: [\n    { role: 'user', content: prompt }\n  ]\n};\n\nreturn {\n  requestBody: JSON.stringify(requestBody),\n  preferredSections: sections,\n  mode: mode\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-40, 336],
      "id": "build-claude-request-node",
      "name": "Build Claude Request"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "anthropic-version", "value": "2023-06-01" },
            { "name": "content-type", "value": "application/json" }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.requestBody }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [200, 336],
      "id": "78c5a8d2-6fbb-46c8-b4bf-e26b99c9cd07",
      "name": "Claude - JSON Extraction"
    },
    {
      "parameters": {
        "jsCode": "// Strict JSON parser with section whitelist enforcement v4\n\nconst claudeResponse = $json.content[0].text;\n\nconst buildData = $('Build Claude Request').item.json;\nconst expectedSections = buildData.preferredSections || ['ANAMNEZA', 'STATUS', 'DIJAGNOZA', 'TERAPIJA', 'PREPORUKE'];\nconst mode = buildData.mode || 'new';\n\n// Administrative keys that should never appear in output\nconst ADMIN_BLACKLIST = new Set([\n  'PODACI O PACIJENTU', 'DATUM PREGLEDA', 'IME I PREZIME', 'JMBG',\n  'DATUM ROĐENJA', 'ADRESA', 'KONTAKT', 'BROJ PROTOKOLA',\n  'MATIČNI BROJ', 'DATUM NALAZA', 'ZAKLJUČAK'\n]);\n\nlet sections = null;\nlet parseError = null;\n\ntry {\n  let cleanedResponse = claudeResponse\n    .replace(/```json\\n?/g, '')\n    .replace(/```\\n?/g, '')\n    .trim();\n\n  // Extract JSON if wrapped in other text\n  const jsonStart = cleanedResponse.indexOf('{');\n  const jsonEnd = cleanedResponse.lastIndexOf('}');\n  if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {\n    cleanedResponse = cleanedResponse.slice(jsonStart, jsonEnd + 1);\n  }\n\n  const parsed = JSON.parse(cleanedResponse);\n\n  // Strict whitelist: only allow expected sections + _napomene\n  const allowedKeys = new Set(expectedSections.map(s => s.toUpperCase()));\n  allowedKeys.add('_napomene');\n\n  sections = {};\n  for (const [key, value] of Object.entries(parsed)) {\n    const upperKey = key.toUpperCase();\n\n    // Skip blacklisted admin sections\n    if (ADMIN_BLACKLIST.has(upperKey)) continue;\n\n    // Skip sections not in doctor's preferences (except _napomene)\n    if (key !== '_napomene' && !allowedKeys.has(upperKey)) continue;\n\n    // Skip empty/null/N-A values — zero-hallucination: don't forward empty sections\n    if (value === null || value === undefined || value === '' || value === 'N/A' || value === 'n/a') continue;\n\n    sections[key] = value;\n  }\n\n} catch (error) {\n  parseError = error.message;\n\n  // Fallback: try to use raw text as first section\n  sections = {};\n  if (claudeResponse && claudeResponse.length > 10) {\n    sections[expectedSections[0]] = claudeResponse;\n  }\n}\n\nconst timestamp = new Date().toISOString();\nconst datumNalaza = new Date().toLocaleDateString('bs-BA');\n\nreturn {\n  success: !parseError,\n  sections: sections,\n  metadata: {\n    generatedAt: timestamp,\n    datumNalaza: datumNalaza,\n    version: 'AIMED-transcribe-v4',\n    mode: mode,\n    parseError: parseError\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 336],
      "id": "9e1bdbbf-3df1-49b6-852b-be921e943382",
      "name": "Parse JSON Response"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [680, 336],
      "id": "0eeb0f23-2f7e-485f-a7df-f30cb50ce809",
      "name": "Respond with JSON"
    }
  ]
}
